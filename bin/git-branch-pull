#! /bin/sh

usage() {
    cat << EOF
Usage:
    git branch-pull [--fetch-only|--ff-only|--rebase|--merge] [<remote-branch>]
EOF
}

help() {
    cat << EOF
Description:
    A simpler interface for git pull, which:
        - refers to remote branches by slashed name
        - summarizes the commits and file changes to be pulled

EOF
usage
    cat << EOF

Options:
    <remote-branch>
        The remote branch to pull to in the form "<remote>/<branch>". If <remote-branch> is
        omitted, it defaults to the current branch's upstream.
    --fetch-only
        Fetch the lastest changes, without integrating them.
    --ff-only
        Only attempt a fast-forward merge.
    --merge
        Merges the remote branch into the current branch.
    --rebase
        Rebase local commits on top of the remote branch. This is the default behaviour.
EOF
}

fail() {
    echo $@ 1>&2
    exit 1
}

usageFail() {
    echo "Error: $@" 1>&2
    usage
    exit 1
}

case "$1" in
--fetch-only)
    fetchOnlyMode='true'
    shift
    ;;
--ff-only)
    ffOnlyMode='true'
    shift
    ;;
--rebase)
    shift
    ;;
--merge)
    mergeMode='true'
    shift
    ;;
--help|-h)
    help
    exit 0
    ;;
-*)
    usageFail "Unrecognized option: \"$1\""
    ;;
esac

case "$1" in
-*)
    usageFail 'Only one option may be given at a time.'
esac

if [ -z "$1" ]; then
    remoteBranch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2> /dev/null)
    if [ $? -ne 0 ]; then
        fail "Unable to find an upstream branch for \"$(git rev-parse --abbrev-ref HEAD)\"."
    fi
else
    remoteBranch=$1
fi

if [ -n "$2" ]; then
    usage 1
fi

remote=$(echo $remoteBranch | cut -d'/' -f1)
branch=$(echo $remoteBranch | sed "s:^$remote/::")

if [ "$remote/$branch" != "$remoteBranch" ]; then
    fail "\"$remoteBranch\" isn't in the format \"<remote>/<branch>\""
fi

if [ "$(git remote 2> /dev/null 2> /dev/null | grep $remote)" != "$remote"  ]; then
    fail "\"$remote\" doesn't appear to be a valid remote."
fi

echo 'Fetching:'
git fetch $remote || exit 1

headHash="$(git rev-parse HEAD)"
remoteHash="$(git rev-parse $remoteBranch)"
mergeBase="$(git merge-base HEAD "$remoteBranch")"
if [ "$mergeBase" = "$remoteHash" ]; then
    echo 'Already up to date.'
else
    echo
    echo 'Incoming commits:'
    git --no-pager log --reverse --use-mailmap --format=format:'%C(magenta)%ar %C(green)%an%Creset %s' $mergeBase..$remoteHash
    echo
    echo
    echo 'Files changed:'
    git --no-pager diff --stat $mergeBase..$remoteHash
    echo

    if [ "$fetchOnlyMode" != 'true' ]; then
        if [ "$ffOnlyMode" = 'true' -a "$mergeBase" != "$headHash" ]; then
            fail 'Fast forward merge not possible.'
        elif [ "$mergeMode" = 'true' ]; then
            git merge $remoteBranch
        else
            git rebase --autostash $remoteBranch
        fi
        exit $?
    fi
fi

